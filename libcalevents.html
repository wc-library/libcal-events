<div id="events">&nbsp;</div>
<script>

// Get JSON for events and put it into HTML

var url = "https://api.library.wheaton.edu/libcal/"; // URL to where you are getting JSON that is from the LibCal API. 
var events = "";


$.getJSON(url, function(data){
    loadEvents(data);
    events = data;
  });


// FUNCTIONS
function processEventList(events) {
  if (!events || events.length === 0) {
    return events;
  }

  // Extract all event_ids from future_dates to identify series
  const allEventIds = new Set();
  const eventIdToSeriesMap = new Map(); // Maps event_ids to series identifiers
  let seriesCounter = 0;
  
  // First pass: collect all event_ids and create series mappings
  events.forEach(event => {
    if (event.future_dates && event.future_dates.length > 0) {
      // Check if this event connects to an existing series
      let foundSeries = false;
      let seriesId = null;
      
      for (const futureDate of event.future_dates) {
        const eventId = futureDate.event_id;
        allEventIds.add(eventId);
        
        // If this event_id is already part of a series
        if (eventIdToSeriesMap.has(eventId)) {
          seriesId = eventIdToSeriesMap.get(eventId);
          foundSeries = true;
          break;
        }
      }
      
      // If not found in existing series, create a new one
      if (!foundSeries) {
        seriesId = `series_${seriesCounter++}`;
      }
      
      // Assign all future_date event_ids to this series
      event.future_dates.forEach(futureDate => {
        eventIdToSeriesMap.set(futureDate.event_id, seriesId);
      });
      
      // Also assign this event's id to the series if it exists
      if (event.id) {
        eventIdToSeriesMap.set(event.id, seriesId);
      }
    }
  });
  
  // If no events have future_dates, return the original array
  if (allEventIds.size === 0) {
    return events;
  }
  
  // Second pass: group events by series
  const seriesGroups = new Map(); // Maps series identifiers to arrays of events
  
  events.forEach(event => {
    // Skip events without IDs
    if (!event.id) {
      return;
    }
    
    let seriesId = eventIdToSeriesMap.get(event.id);
    
    // If the event ID isn't in our map but it has future_dates, 
    // check its future_dates for series membership
    if (!seriesId && event.future_dates && event.future_dates.length > 0) {
      for (const futureDate of event.future_dates) {
        seriesId = eventIdToSeriesMap.get(futureDate.event_id);
        if (seriesId) break;
      }
    }
    
    // If this event belongs to a series, add it to that group
    if (seriesId) {
      if (!seriesGroups.has(seriesId)) {
        seriesGroups.set(seriesId, []);
      }
      seriesGroups.get(seriesId).push(event);
    }
  });
  
  // Create a set to track which events to include
  const eventsToInclude = new Set();
  
  // Process each series, keeping only the earliest two events
  seriesGroups.forEach(seriesEvents => {
    // Sort the series events by date
    seriesEvents.sort((a, b) => new Date(a.start) - new Date(b.start));
    
    // Take only the earliest two events from the series
    eventsToInclude.add(seriesEvents[0].id);
    if (seriesEvents.length > 1) {
      eventsToInclude.add(seriesEvents[1].id);
    }
  });
  
  // Filter the events list
  const processedEvents = events.filter(event => {
    // Include all events without an ID
    if (!event.id) {
      return true;
    }
    
    // Include events not part of any series
    if (!eventIdToSeriesMap.has(event.id)) {
      return true;
    }
    
    // Include events that were selected from their series
    return eventsToInclude.has(event.id);
  });
  
  // Sort the processed events by date
  processedEvents.sort((a, b) => {
    return new Date(a.start) - new Date(b.start);
  });
  
  return processedEvents;
}

function loadEvents(events){

    var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    
    var eventHTML = "<div class='events'><h2>Events</h2>";
    
    // Build data model that's needed for display  (could move to serverside)
    if(events.length > 0){
      // Process the events to filter recurring series
      events = processEventList(events);
      for (var i = 0; i < events.length; i++) {
      e = events[i];
          var msec = Date.parse(e.start);
          var date = new Date(msec);
          eventHTML += "<div class='eventcard'>";
          eventHTML += "<div class='eventdate'>"+months[date.getMonth()].slice(0,3) + "<br />"  +date.getDate() + "</div>";
          eventHTML += "<div class='eventinfo'><ul>";
          eventHTML += "<li class='eventtitle'><h3>"+e.title+"</h3></li>";
          eventHTML += "<li class='eventtime'>"+formatTime(e.start);
          if(e.end){
            eventHTML += " - " + formatTime(e.end) + "</li>";
          }
          else{
            eventHTML +="</li>";
          }
          if(e.audience){
            eventHTML += "<li class='eventaudience'>Audience: ";
            for (var a = e.audience.length - 1; a >= 0; a--) {
              eventHTML += "<em>"+e.audience[a].name+"</em>";
              if (a>0) { 
                eventHTML += ",";
                
              } 
              else if (a==0){
                eventHTML += "</li>";
              } 
            }

          }
          if(e.location.name !== ""){
            eventHTML += "<li class='eventlocation'>"+e.location.name+"</li>";
          }
          eventHTML += "<li class='eventpresenter'>"+e.presenter+"</li>";
          eventHTML += "<li class=''><a href='"+e.url.public+"' target='_blank'>More info</a></li>";
          eventHTML += "</ul></div></div>";
      }
    eventHTML += "</div>";
  }else{
    eventHTML += "There are no events on the calendar in the next 6 months at the moment.</div>";
  }
    
  // Write HTML to container
  document.getElementById('events').innerHTML = eventHTML;
}

function formatTime(etime){
  var msec = Date.parse(etime);
  var date = new Date(msec);
  var time = "";
  var ampm = "AM";
  hours = date.getHours();
  if(hours >= 12){
    if (hours > 12) {
        hours = hours - 12;
        }
    ampm = "PM";
  }

  var min = date.getMinutes();
  if(min === 0){
    min = "00";
  }
  time = hours + ":" + min +" "+ampm;
  return time;
}

</script>
<style type="text/css">/* CSS for the accompanying HTML */
  .eventcard {
    padding: 1em;
    background-color:#f5f5f5;
    display: flex;
    border-radius: 2px;
    margin-bottom: 1em;
  }
  .eventdate  {
    min-width: 4.4rem;
    height: 5rem;
    margin-right: 1rem;
    background-color:#0069aa;
    color:#fff;
    text-align: center;
    margin-top: 24px;
    padding-top: 1rem;
    border-radius: 2px;
  }

.eventinfo ul{
  list-style: none;
}
.eventtitle h3 {
    font-size: large;
}
.eventlocation {
  font-style: italic;
}
#full-calendar {text-align:right;}
</style>
<div id="full-calendar"><a href="https://calendar.library.wheaton.edu/calendars" target="_blank">Full Events Calendar</a></div>

